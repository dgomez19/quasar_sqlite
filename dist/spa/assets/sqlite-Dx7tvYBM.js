const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/web-B3qoxSTM.js","assets/index-DWXaZSRs.js","assets/index-BU48QWcs.css"])))=>i.map(i=>d[i]);
import{a1 as te}from"./index-DWXaZSRs.js";/*! Capacitor: https://capacitorjs.com/ - MIT License */const re=i=>{const e=new Map;e.set("web",{name:"web"});const t=i.CapacitorPlatforms||{currentPlatform:{name:"web"},platforms:e},r=(s,a)=>{t.platforms.set(s,a)},n=s=>{t.platforms.has(s)&&(t.currentPlatform=t.platforms.get(s))};return t.addPlatform=r,t.setPlatform=n,t},se=i=>i.CapacitorPlatforms=re(i),Q=se(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});Q.addPlatform;Q.setPlatform;var C;(function(i){i.Unimplemented="UNIMPLEMENTED",i.Unavailable="UNAVAILABLE"})(C||(C={}));class T extends Error{constructor(e,t,r){super(e),this.message=e,this.code=t,this.data=r}}const ne=i=>{var e,t;return i?.androidBridge?"android":!((t=(e=i?.webkit)===null||e===void 0?void 0:e.messageHandlers)===null||t===void 0)&&t.bridge?"ios":"web"},ie=i=>{var e,t,r,n,s;const a=i.CapacitorCustomPlatform||null,o=i.Capacitor||{},l=o.Plugins=o.Plugins||{},c=i.CapacitorPlatforms,q=()=>a!==null?a.name:ne(i),p=((e=c?.currentPlatform)===null||e===void 0?void 0:e.getPlatform)||q,_=()=>p()!=="web",I=((t=c?.currentPlatform)===null||t===void 0?void 0:t.isNativePlatform)||_,H=d=>{const u=k.get(d);return!!(u?.platforms.has(p())||A(d))},J=((r=c?.currentPlatform)===null||r===void 0?void 0:r.isPluginAvailable)||H,G=d=>{var u;return(u=o.PluginHeaders)===null||u===void 0?void 0:u.find(v=>v.name===d)},A=((n=c?.currentPlatform)===null||n===void 0?void 0:n.getPluginHeader)||G,V=d=>i.console.error(d),z=(d,u,v)=>Promise.reject(`${v} does not have an implementation of "${u}".`),k=new Map,K=(d,u={})=>{const v=k.get(d);if(v)return console.warn(`Capacitor plugin "${d}" already registered. Cannot register plugins twice.`),v.proxy;const b=p(),j=A(d);let P;const Y=async()=>(!P&&b in u?P=typeof u[b]=="function"?P=await u[b]():P=u[b]:a!==null&&!P&&"web"in u&&(P=typeof u.web=="function"?P=await u.web():P=u.web),P),Z=(h,m)=>{var f,w;if(j){const g=j?.methods.find(y=>m===y.name);if(g)return g.rtype==="promise"?y=>o.nativePromise(d,m.toString(),y):(y,L)=>o.nativeCallback(d,m.toString(),y,L);if(h)return(f=h[m])===null||f===void 0?void 0:f.bind(h)}else{if(h)return(w=h[m])===null||w===void 0?void 0:w.bind(h);throw new T(`"${d}" plugin is not implemented on ${b}`,C.Unimplemented)}},x=h=>{let m;const f=(...w)=>{const g=Y().then(y=>{const L=Z(y,h);if(L){const E=L(...w);return m=E?.remove,E}else throw new T(`"${d}.${h}()" is not implemented on ${b}`,C.Unimplemented)});return h==="addListener"&&(g.remove=async()=>m()),g};return f.toString=()=>`${h.toString()}() { [capacitor code] }`,Object.defineProperty(f,"name",{value:h,writable:!1,configurable:!1}),f},R=x("addListener"),U=x("removeListener"),ee=(h,m)=>{const f=R({eventName:h},m),w=async()=>{const y=await f;U({eventName:h,callbackId:y},m)},g=new Promise(y=>f.then(()=>y({remove:w})));return g.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await w()},g},O=new Proxy({},{get(h,m){switch(m){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return j?ee:R;case"removeListener":return U;default:return x(m)}}});return l[d]=O,k.set(d,{name:d,proxy:O,platforms:new Set([...Object.keys(u),...j?[b]:[]])}),O},X=((s=c?.currentPlatform)===null||s===void 0?void 0:s.registerPlugin)||K;return o.convertFileSrc||(o.convertFileSrc=d=>d),o.getPlatform=p,o.handleError=V,o.isNativePlatform=I,o.isPluginAvailable=J,o.pluginMethodNoop=z,o.registerPlugin=X,o.Exception=T,o.DEBUG=!!o.DEBUG,o.isLoggingEnabled=!!o.isLoggingEnabled,o.platform=o.getPlatform(),o.isNative=o.isNativePlatform(),o},oe=i=>i.Capacitor=ie(i),D=oe(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),$=D.registerPlugin;D.Plugins;class B{constructor(e){this.listeners={},this.retainedEventArguments={},this.windowListeners={},e&&(console.warn(`Capacitor WebPlugin "${e.name}" config object was deprecated in v3 and will be removed in v4.`),this.config=e)}addListener(e,t){let r=!1;this.listeners[e]||(this.listeners[e]=[],r=!0),this.listeners[e].push(t);const s=this.windowListeners[e];s&&!s.registered&&this.addWindowListener(s),r&&this.sendRetainedArgumentsForEvent(e);const a=async()=>this.removeListener(e,t);return Promise.resolve({remove:a})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,r){const n=this.listeners[e];if(!n){if(r){let s=this.retainedEventArguments[e];s||(s=[]),s.push(t),this.retainedEventArguments[e]=s}return}n.forEach(s=>s(t))}hasListeners(e){return!!this.listeners[e].length}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:r=>{this.notifyListeners(t,r)}}}unimplemented(e="not implemented"){return new D.Exception(e,C.Unimplemented)}unavailable(e="not available"){return new D.Exception(e,C.Unavailable)}async removeListener(e,t){const r=this.listeners[e];if(!r)return;const n=r.indexOf(t);this.listeners[e].splice(n,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){e&&(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];t&&(delete this.retainedEventArguments[e],t.forEach(r=>{this.notifyListeners(e,r)}))}}const W=i=>encodeURIComponent(i).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),M=i=>i.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent);class ae extends B{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach(r=>{if(r.length<=0)return;let[n,s]=r.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");n=M(n).trim(),s=M(s).trim(),t[n]=s}),t}async setCookie(e){try{const t=W(e.key),r=W(e.value),n=`; expires=${(e.expires||"").replace("expires=","")}`,s=(e.path||"/").replace("path=",""),a=e.url!=null&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${r||""}${n}; path=${s}; ${a};`}catch(t){return Promise.reject(t)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(t){return Promise.reject(t)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}}$("CapacitorCookies",{web:()=>new ae});const ce=async i=>new Promise((e,t)=>{const r=new FileReader;r.onload=()=>{const n=r.result;e(n.indexOf(",")>=0?n.split(",")[1]:n)},r.onerror=n=>t(n),r.readAsDataURL(i)}),le=(i={})=>{const e=Object.keys(i);return Object.keys(i).map(n=>n.toLocaleLowerCase()).reduce((n,s,a)=>(n[s]=i[e[a]],n),{})},de=(i,e=!0)=>i?Object.entries(i).reduce((r,n)=>{const[s,a]=n;let o,l;return Array.isArray(a)?(l="",a.forEach(c=>{o=e?encodeURIComponent(c):c,l+=`${s}=${o}&`}),l.slice(0,-1)):(o=e?encodeURIComponent(a):a,l=`${s}=${o}`),`${r}&${l}`},"").substr(1):null,ue=(i,e={})=>{const t=Object.assign({method:i.method||"GET",headers:i.headers},e),n=le(i.headers)["content-type"]||"";if(typeof i.data=="string")t.body=i.data;else if(n.includes("application/x-www-form-urlencoded")){const s=new URLSearchParams;for(const[a,o]of Object.entries(i.data||{}))s.set(a,o);t.body=s.toString()}else if(n.includes("multipart/form-data")||i.data instanceof FormData){const s=new FormData;if(i.data instanceof FormData)i.data.forEach((o,l)=>{s.append(l,o)});else for(const o of Object.keys(i.data))s.append(o,i.data[o]);t.body=s;const a=new Headers(t.headers);a.delete("content-type"),t.headers=a}else(n.includes("application/json")||typeof i.data=="object")&&(t.body=JSON.stringify(i.data));return t};class he extends B{async request(e){const t=ue(e,e.webFetchExtra),r=de(e.params,e.shouldEncodeUrlParams),n=r?`${e.url}?${r}`:e.url,s=await fetch(n,t),a=s.headers.get("content-type")||"";let{responseType:o="text"}=s.ok?e:{};a.includes("application/json")&&(o="json");let l,c;switch(o){case"arraybuffer":case"blob":c=await s.blob(),l=await ce(c);break;case"json":l=await s.json();break;case"document":case"text":default:l=await s.text()}const q={};return s.headers.forEach((p,_)=>{q[_]=p}),{data:l,headers:q,status:s.status,url:s.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}}$("CapacitorHttp",{web:()=>new he});class me{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getFromLocalDiskToStore(e){const t=e??!0;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async createConnection(e,t,r,n,s){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:r,version:n,readonly:s});const a=new F(e,s,this.sqlite),o=s?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(o,a),Promise.resolve(a)}catch(a){return Promise.reject(a)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const r=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(r),Promise.resolve()}catch(r){return Promise.reject(r)}}async isConnection(e,t){const r={};e.endsWith(".db")&&(e=e.slice(0,-3));const n=t?`RO_${e}`:`RW_${e}`;return r.result=this._connectionDict.has(n),Promise.resolve(r)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const r=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(r)){const n=this._connectionDict.get(r);return typeof n<"u"?Promise.resolve(n):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const r=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const r=new F(e,!0,this.sqlite),n=`RO_${e})`;return this._connectionDict.set(n,r),Promise.resolve(r)}catch(r){return Promise.reject(r)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}}async isNCConnection(e){const t={},r=`RO_${e})`;return t.result=this._connectionDict.has(r),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,r=this._connectionDict.get(t);return typeof r<"u"?Promise.resolve(r):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const r=t.substring(3),n=t.substring(0,3)==="RO_";await this.sqlite.closeConnection({database:r,readonly:n}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],r=[];for(const s of e)t.push(s.substring(0,2)),r.push(s.substring(3));const n=await this.sqlite.checkConnectionsConsistency({dbNames:r,openModes:t});return n.result||(this._connectionDict=new Map),Promise.resolve(n)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async copyFromAssets(e){const t=e??!0;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async getFromHTTPRequest(e,t){const r=t??!0;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:r}),Promise.resolve()}catch(n){return Promise.reject(n)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async getDatabaseList(){try{const t=(await this.sqlite.getDatabaseList()).values;t.sort();const r={values:t};return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const r=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async addSQLiteSuffix(e,t){const r=e||"default",n=t||[];try{const s=await this.sqlite.addSQLiteSuffix({folderPath:r,dbNameList:n});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async deleteOldDatabases(e,t){const r=e||"default",n=t||[];try{const s=await this.sqlite.deleteOldDatabases({folderPath:r,dbNameList:n});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async moveDatabasesAndAddSuffix(e,t){const r=e||"default",n=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:r,dbNameList:n})}}class F{constructor(e,t,r){this.dbName=e,this.readonly=t,this.sqlite=r}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,r=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const n=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:r});return Promise.resolve(n)}}catch(n){return Promise.reject(n)}}async query(e,t,r=!0){let n;try{return t&&t.length>0?n=await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):n=await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:r}),n=await this.reorderRows(n),Promise.resolve(n)}catch(s){return Promise.reject(s)}}async run(e,t,r=!0,n="no",s=!0){let a;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(t&&t.length>0?a=await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:r,readonly:!1,returnMode:n,isSQL92:!0}):a=await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:r,readonly:!1,returnMode:n,isSQL92:s}),a.changes=await this.reorderRows(a.changes),Promise.resolve(a))}catch(o){return Promise.reject(o)}}async executeSet(e,t=!0,r="no",n=!0){let s;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(s=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:r,isSQL92:n}),s.changes=await this.reorderRows(s.changes),Promise.resolve(s))}catch(a){return Promise.reject(a)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(e.syncDate*1e3).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const r=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let r=0,n=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),n=await this.sqlite.isTransactionActive({database:this.dbName}),!n)return Promise.reject("After Begin Transaction, no transaction active");try{for(const o of e){if(typeof o!="object"||!("statement"in o))throw new Error("Error a task.statement must be provided");if("values"in o&&o.values&&o.values.length>0){const l=o.statement.toUpperCase().includes("RETURNING")?"all":"no",c=await this.sqlite.run({database:this.dbName,statement:o.statement,values:o.values,transaction:!1,readonly:!1,returnMode:l,isSQL92:t});if(c.changes.changes<0)throw new Error("Error in transaction method run ");r+=c.changes.changes}else{const l=await this.sqlite.execute({database:this.dbName,statements:o.statement,transaction:!1,readonly:!1});if(l.changes.changes<0)throw new Error("Error in transaction method execute ");r+=l.changes.changes}}const s=await this.sqlite.commitTransaction({database:this.dbName});r+=s.changes.changes;const a={changes:{changes:r}};return Promise.resolve(a)}catch(s){const a=s.message?s.message:s;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(a)}}async reorderRows(e){const t=e;if(e?.values&&typeof e.values[0]=="object"&&Object.keys(e.values[0]).includes("ios_columns")){const r=e.values[0].ios_columns,n=[];for(let s=1;s<e.values.length;s++){const a=e.values[s],o={};for(const l of r)o[l]=a[l];n.push(o)}t.values=n}return Promise.resolve(t)}}const ye=$("CapacitorSQLite",{web:()=>te(()=>import("./web-B3qoxSTM.js"),__vite__mapDeps([0,1,2])).then(i=>new i.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite});let N,S;const fe=async()=>{try{return N||(N=new me(ye)),S?console.log("⚠️ La conexión ya existe, reutilizándola."):(S=await N.createConnection("myDatabase",!1,"no-encryption",1),await S.open(),console.log("✅ Base de datos inicializada")),S}catch(i){console.error("❌ Error al inicializar SQLite:",i)}},we=Object.freeze(Object.defineProperty({__proto__:null,initSQLite:fe},Symbol.toStringTag,{value:"Module"}));export{B as W,fe as i,we as s};
